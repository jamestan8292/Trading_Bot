# USE TRADING SIGNALS GENERATED BY CALLING MODULE TO PERFORM BACKTEST.
# OUTPUTS: 
#   - PROFIT/LOSS and ROI
#   - CUMULACTIVE RETURNS DATAFRAME
#   - PERFORMANCE METRICS (ANNUALIZED RETURN, CUMULATIVE RETURNS, ANNUAL VOLATILITY, SHARPE RATIO, SORTINA RATIO)

import numpy as np
import pandas as pd
import hvplot.pandas
from pathlib import Path

amd_df = pd.read_csv(
    Path("../Resources/amd_data.csv"),
    index_col="date",
    parse_dates=True, 
    infer_datetime_format=True
)

# Review the DataFrame
amd_df.head()

# Visualize the DataFrame using the plot function 
amd_df.plot()

# Initialize trade_type column for buys and sells
amd_df['trade_type'] = np.nan

# Initialize variable to hold the previous_price
previous_price = 0

# Loop through the Pandas DataFrame and initiate a trade at each iteration 
for index, row in amd_df.iterrows():
    
    # buy if the previous price is 0, in other words, buy on the first day
    if previous_price == 0:
        amd_df.loc[index, "trade_type"] = "buy"

    # buy if the current day price is less than the previous day price
    elif row["close"] < previous_price:
        amd_df.loc[index, "trade_type"] = "buy"

    # hold if the current day price is greater than the previous day price
    elif row["close"] > previous_price:
        amd_df.loc[index, "trade_type"] = "hold"

    # as well, hold if the current day price is equal to the previous day price
    else:
        amd_df.loc[index, "trade_type"] = "hold"
    
    # set the previous_price variable to the close price of the current row
    previous_price = row["close"]

    # if the index is the last index of the Dataframe, set the trade_type to sell
    if index == amd_df.index[-1]:
        amd_df.loc[index, "trade_type"] = "sell"

# Run the algorithm and review the DataFrame
amd_df

# Initialize trade_type column for buys and sells
amd_df['trade_type'] = np.nan

# Initialize `profit/loss` column for recording trade metrics
amd_df["cost/proceeds"] = np.nan

### modifying the loop to include the cost and proceeds metrics for buys of 100 shares.

# Initialize share size and accumulated shares
share_size = 100
accumulated_shares = 0

# Initialize variable to hold previous price
previous_price = 0

# Loop through the Pandas DataFrame and initiate a trade at each iteration 
for index, row in amd_df.iterrows():

    # buy if the previous price is 0, in other words, buy on the first day
    # set the cost/proceeds column equal to the negative value of the row close price
    # multiplied by the share_size
    if previous_price == 0:
        amd_df.loc[index, "trade_type"] = "buy"
        amd_df.loc[index, "cost/proceeds"] = -(row["close"] * share_size)
        accumulated_shares += share_size

    # buy if the current day price is less than the previous day price
    # set the cost/proceeds column equal to the negative value of the row close price
    # multiplied by the share_size
    elif row["close"] < previous_price:
        amd_df.loc[index, "trade_type"] = "buy"
        amd_df.loc[index, "cost/proceeds"] = -(row["close"] * share_size)
        accumulated_shares += share_size
    
    # hold if the current day price is greater than the previous day price
    elif row["close"] > previous_price:
        amd_df.loc[index, "trade_type"] = "hold"

    # also hold if the current day price is equal to the previous day price
    else:
        amd_df.loc[index, "trade_type"] = "hold"
    
    # set the previous_price variable to the close price of the current row
    previous_price = row["close"]
    
    # if the index is the last index of the Dataframe, sell
    # set the cost/proceeds column equal to the row close price multiplied 
    # by the accumulated_shares
    if index == amd_df.index[-1]:
        amd_df.loc[index, "trade_type"] = "sell"
        amd_df.loc[index, "cost/proceeds"] = row["close"] * accumulated_shares

        
# Calculate the total profit/loss for 100 share size orders
total_profit_loss = round(amd_df["cost/proceeds"].sum(), 2)

# Print the profit/loss metrics
print(f"The total profit/loss of the trading strategy is ${total_profit_loss}.")
        
# Initialize the variable to hold the value of the invested capital
invested_capital = 0 

# Calculate the invested capital by adding the cost of all buy trades
for index, row in amd_df.iterrows():
    if row["trade_type"] == "buy":
        invested_capital = invested_capital + row["cost/proceeds"]
        
        
# Calculate the return on investment (ROI)
roi = round((total_profit_loss / -(invested_capital)) * 100, 2)
         
# Print the ROI
print(f"The trading algorithm resulted in a return on investment of {roi}%")


### Create the list of the metric names

metrics = [
    'Annualized Return',
    'Cumulative Returns',
    'Annual Volatility',
    'Sharpe Ratio',
    'Sortino Ratio'
]

# Create a list that holds the column name
columns = ['Backtest']

# Initialize the DataFrame with index set to evaluation metrics and columns 
portfolio_evaluation_df = pd.DataFrame(index=metrics, columns=columns)

# Review the DataFrame
portfolio_evaluation_df

# Calculate the Annualized return metric
portfolio_evaluation_df.loc['Annualized Return'] = (
    signals_df['Portfolio Daily Returns'].mean() * 252
)

# Calculate the Cumulative returns metric
portfolio_evaluation_df.loc['Cumulative Returns'] = signals_df['Portfolio Cumulative Returns'][-1]

# Calculate the Annual volatility metric
portfolio_evaluation_df.loc['Annual Volatility'] = (
    signals_df['Portfolio Daily Returns'].std() * np.sqrt(252)
)

# Calculate the Sharpe ratio
portfolio_evaluation_df.loc['Sharpe Ratio'] = (
    signals_df['Portfolio Daily Returns'].mean() * 252) / (
    signals_df['Portfolio Daily Returns'].std() * np.sqrt(252)
)

# Calculate the Sortino ratio
# Start by calculating the downside return values

# Create a DataFrame that contains the Portfolio Daily Returns column
sortino_ratio_df = signals_df[['Portfolio Daily Returns']]

# Create a column to hold downside return values
sortino_ratio_df.loc[:,'Downside Returns'] = 0

# Find Portfolio Daily Returns values less than 0, 
# square those values, and add them to the Downside Returns column
sortino_ratio_df.loc[sortino_ratio_df['Portfolio Daily Returns'] < 0, 
                     'Downside Returns'] = sortino_ratio_df['Portfolio Daily Returns']**2

# Calculate the annualized return value
annualized_return = sortino_ratio_df['Portfolio Daily Returns'].mean() * 252

# Calculate the annualized downside standard deviation value
downside_standard_deviation = np.sqrt(sortino_ratio_df['Downside Returns'].mean()) * np.sqrt(252)

# Divide the annualized return value by the downside standard deviation value
sortino_ratio = annualized_return/downside_standard_deviation

# Add the Sortino ratio to the evaluation DataFrame
portfolio_evaluation_df.loc['Sortino Ratio'] = sortino_ratio

# Review the portfolio evaluation DataFrame
portfolio_evaluation_df

 Initialize the trade evaluation DataFrame
trade_evaluation_df = pd.DataFrame(
    columns=[
        'Stock', 
        'Entry Date', 
        'Exit Date', 
        'Shares', 
        'Entry Share Price', 
        'Exit Share Price', 
        'Entry Portfolio Holding', 
        'Exit Portfolio Holding', 
        'Profit/Loss']
)

# Initialize the iterative variables
entry_date = ""
exit_date = ""
entry_portfolio_holding = 0.0
exit_portfolio_holding = 0.0
share_size = 0
entry_share_price = 0.0
exit_share_price = 0.0

# Loop through the signal DataFrame
# If `Entry/Exit` is 1, set entry trade metrics
# Else if `Entry/Exit` is -1, set exit trade metrics and calculate profit,
# Then append the record to the trade evaluation DataFrame
for index, row in signals_df.iterrows():
    if row['Entry/Exit'] == 1:
        entry_date = index
        entry_portfolio_holding = abs(row['Portfolio Holdings'])
        share_size = row['Entry/Exit Position']
        entry_share_price = row['Close']

    elif row['Entry/Exit'] == -1:
        exit_date = index
        exit_portfolio_holding = abs(row['Close'] * row['Entry/Exit Position'])
        exit_share_price = row['Close']
        profit_loss =  entry_portfolio_holding - exit_portfolio_holding
        trade_evaluation_df = trade_evaluation_df.append(
            {
                'Stock': 'AAPL',
                'Entry Date': entry_date,
                'Exit Date': exit_date,
                'Shares': share_size,
                'Entry Share Price': entry_share_price,
                'Exit Share Price': exit_share_price,
                'Entry Portfolio Holding': entry_portfolio_holding,
                'Exit Portfolio Holding': exit_portfolio_holding,
                'Profit/Loss': profit_loss
            },
            ignore_index=True)

# Review the DataFrame
trade_evaluation_df